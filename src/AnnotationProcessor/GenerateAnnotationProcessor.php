<?php
/**
 * @copyright 2014-2018 Hostnet B.V.
 */
declare(strict_types=1);

namespace Hostnet\Component\AccessorGenerator\AnnotationProcessor;

use Hostnet\Component\AccessorGenerator\Annotation\Enumerator;
use Hostnet\Component\AccessorGenerator\Annotation\Generate;

/**
 * Processes the @Generate annotation and determines which methods should be
 * generated by the code generator. Store everything in a PropertyInformation
 * object.
 */
class GenerateAnnotationProcessor implements AnnotationProcessorInterface
{
    /**
     * @see AnnotationProcessorInterface::processAnnotation()
     *
     * @param object              $annotation
     * @param PropertyInformation $info
     */
    public function processAnnotation($annotation, PropertyInformation $info): void
    {
        // Standalone Enumerator annotation.
        if ($annotation instanceof Enumerator) {
            if (!\class_exists($annotation->getType())) {
                return;
            }
            $info->addEnumeratorToGenerate($annotation);
            $annotation->property = $info->getName();
            if (! $info->getType() && $annotation->getType()) {
                $info->setType($annotation->getType());
            }
            return;
        }

        // Only process Generate annotations from this point.
        if (!$annotation instanceof Generate) {
            return;
        }

        $info->setIsGenerator(true);

        if ($annotation->getEnumerators()) {
            $annotation->setDefaultVisibility(Generate::VISIBILITY_NONE);
            foreach ($annotation->getEnumerators() as $enumerator) {
                $info->addEnumeratorToGenerate($enumerator);
            }
        } else {
            $annotation->setDefaultVisibility(Generate::VISIBILITY_PUBLIC);
        }

        // By default no method is generated.
        //
        // Each processor can enforce a limitation on the generated methods.
        // If processor A lets a method be private, and processor B tells it to
        // be protected, it will end up private.

        $info->limitMaximumGetVisibility(
            Generate::getMostLimitedVisibility($annotation->getGet(), $annotation->getIs())
        );
        $info->limitMaximumSetVisibility(
            Generate::getMostLimitedVisibility($annotation->getSet())
        );
        $info->limitMaximumAddVisibility(
            Generate::getMostLimitedVisibility($annotation->getAdd(), $annotation->getSet())
        );
        $info->limitMaximumRemoveVisibility(
            Generate::getMostLimitedVisibility($annotation->getRemove(), $annotation->getSet())
        );

        null === $info->getType() && $annotation->getType() && $info->setType($annotation->getType());
        null !== $annotation->getType() && $info->setTypeHint($annotation->getType());
        null !== $annotation->getEncryptionAlias() && $info->setEncryptionAlias($annotation->getEncryptionAlias());

        // Enforce always
        $info->setGenerateStrict($annotation->isStrict());
        $info->setIsGenerator(true);
    }

    /**
     * {@inheritdoc}
     */
    public function getProcessableAnnotationNamespace(): string
    {
        return 'Hostnet\Component\AccessorGenerator\Annotation';
    }
}
